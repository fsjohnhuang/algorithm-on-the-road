# ＜啊哈！算法＞读书笔记
## c01 第一章 一大波数正在靠近-排序
`s01_bucket_sort`, 桶排序(O(N))<br>
`s01_ex1`, 桶排序练习<br>
`s02_bubble_sort`, 冒泡排序(O(N^2))<br>
`s03_quick_sort`, 快速排序(O(NlogN))<br>
`s04_ex_bucketsort`, 小哼买书练习桶排序<br>
`s04_ex_quicksort`, 小哼买书练习快速排序<br>

## c02 第二章 栈,队列,链表
`s01_queue`, 解密QQ号－队列<br>
`s02_stack`, 解密回文－栈<br>
`s03_ex`, 小猫钓鱼<br>
`s04_linklist`, 链表<br>
`s05_mock_linklist`, 模拟链表<br>

## c03 第三章 枚举！很暴力
`s01`, 坑爹的奥数<br>
`s02`, 炸弹人<br>
`s03`, 火柴棍等式<br>
`s03_1`, 火柴棍等式(书中的解法)<br>
`s04`, 数的全排列<br>

## c04 第四章 万能的搜索
`s02`, 解救小哈（深度搜索，作者John E. Hopcropf和Robert E. Tarjan）<br>
`s03`, 层层递进-广度优先搜索(Edward F. Moore"如何从迷宫中寻找出路"提出的解决方案)<br>
`s05`, 宝岛探险(Floodfill,漫水/种子填充法, windows画板填充也是这个算法)<br>
`s06`, 水管工游戏<br>

## c05 第五章 图的遍历
`s01_dfs`, 深度优先遍历(采用了邻接矩阵)，适合计算到达目标路径的某些特征值(如路径，长度等)．时间复杂度O(N^2)<br>
`s01_bfs`, 广度优先遍历(采用了邻接表)，适合计算达到目标所需的最少操作数(经过最少的层级数)．<br>
`s03`, 最少转机－图的广度优先遍历<br>

## c06 第六章 最短路径(注意：回路无法求出最短路径)
`s01`, Floyd-Warshall<br>
目标：求出图上各顶点，两两间最短的距离．(中间可能经过Ｎ个其余的顶点)<br>
思路：为两个顶点引入第三个顶点，从而缩短两顶点间的距离．<br>
关键：遍历所有顶点并将其作为第三个顶点，缩短途中其余两个顶点的距离．<br>
窍门：经过1次计算后，后续计算中第三个顶点到其他顶点的距离可能是间接距离(中间再通过之前计算中的第三个顶点得到的)，因此是一种动态规划的方式．<br>
时间复杂度O(N^3)．<br>
注意：边权重可以为正或负．<br>
  因为每轮操作均会更新所有两两顶点间的权重，所以边权重可正可负．<br>
`s02_am`, Dijkstra, 邻接矩阵实现<br>
目标：求单源最短路径,即求出图上某顶点与其他顶点间最短的距离．(中间可能经过Ｎ个其余的顶点)<br>
思路：将顶点集合分为＂估计值＂集合和＂确定值＂集合,初始状态时＂确定值＂集合中仅包含单源顶点,遍历＂估计值＂集合的所有元素，并以权重最小的作为第三个顶点来＂松弛＂单源顶点与＂估计值＂集合其余顶点的权重，然后将该顶点移至＂确定值＂集合．<br>
关键：每次从＂估计值＂集合中获取权重最小的作为第三个顶点．由于＂确定值＂集合顶点的权重已经是最小值，因此只需对＂估计值＂集合的顶点作松弛即可，而且＂估计值＂集合的顶点可能在前面的计算中已经松弛过，只是松弛后的值依然有再松弛的空间，是一种动态规划的方式．<br>
＂松弛＂：降低两顶点间权重.<br>
时间复杂度O(N^2)或O(NlgN)<br>
注意：边权重仅能为正<br>
＂确定值＂集合内的元素为指定顶点到该元素顶点的最短路径，也就是后续＂估计值＂的松弛行为不能影响已在＂确定值＂集合内的元素．<br>
若存在负权重时，松弛后明显会影响已在＂确定值＂集合内的元素，从而无法形成＂确定值＂集合．<br>
`s02_al`, Dijkstra, 邻接表实现<br>
时间复杂度O((M+N)lgN)？？<br>
`s03`, Bellman-Ford－解决负权边<br>
目标：求单源最短路径,即求出含负权边的图上某顶点与其他顶点间最短的距离．(中间可能经过Ｎ个其余的顶点)<br>
思路：以边为切入点，由于在求最短路径时不可能存在回路，因此N个顶点时最短路径最长为N-1条边组成，那么最多执行N-1轮遍历所有边＂松弛＂某顶点到其他顶点间的距离<br>
时间复杂度O(M\*N)<br>
检测是否存在负权回路：假如可执行N及以上轮＂松弛＂，并＂松弛＂成功，那么即存在负权回路从而无法得到最短路径<br>
`s03_faster`, Bellman-Ford的队列优化<br>
思路：由于＂松弛＂成功的路径会影响以其作为中间顶点的其他顶点的路径距离，因此每一轮仅对上一轮中＂松弛＂成功的顶点出边的终点顶点作松弛<br>

## c07 第七章 神奇的树
### 满二叉树
一颗深度为h并且具有`2^h-1`个节点的二叉树．<br>
所有叶子节点深度一致，均等于树的深度.<br>
### 完全二叉树
一颗深度为N并且除了第N层外其余层级的节点数均等于`2^(h-1)`（其中h为`{1,...,N-1}`），并且第N层从右到左连续缺失多个节点．<br>
一个节点存在右子节点，那么必定存在左字节点．<br>
若节点编号为k,那么左子节点编号为2k,右字节点编号为2k+1<br>
若有N个节点，则树的深度为`log2N`<br>
`s02`, 一维数组存储完全二叉树<br>
### 堆－神奇的优先队列
**最小堆**，父节点值必定小于子节点值的完全二叉树;查找最小值复杂度为O(1)，插入新节点的复杂度为O(logN)
**最大堆**，父节点值必定大于子节点值的完全二叉树;查找最大值复杂度为O(1)，插入新节点的复杂度为O(logN)
`s03_cbt2h`, 普通的完全二叉树转为最小堆或最大堆，时间复杂度为O(N)<br>
思路：自底向上从倒数第二层开始向上遍历每个节点，每一轮均以当前节点作为根节点构建最小或最大堆，最后以整棵树的根节点构建最小或最大堆<br>
**堆排序**，时间复杂度为O(NlogN)
`s03_heapsort1`, 采用最小堆作由小到大的堆排序<br>
思路：每次将根节点从最小堆中移除，并将最后一个叶子节点移至根节点并作向下调整使符合最小堆，直至最小堆大小为0为止<br>
`s03_heapsort2`, 采用最大堆作由小到大的堆排序<br>
思路：每次将根节点和最后一个叶子节点交换，然后堆根节点作部分向下调整使其剩余部分符合最大堆，直接剩余部分只含根节点为止<br>
关键：每次交换后仅对剩余部分左向下调整，剩余部分就是排除当前最后一个叶子节点得到的完全二叉树，那么就可以确保本轮最大值已经移至数组的末尾了．<br>
**优先队列**，支持插入元素和查找最大最小值的数据结构．堆是其中一种实现<br>
`s03_maxk`，求一组数中最大的Ｋ个元素<br>
`s03_mink`，求一组数中最小的Ｋ个元素<br>
`s04`，擒贼先擒王－并查集<br>
**不相交集合数据结构(disjoint-set data structure)**，用于跟踪集合分割成多个不相交子集的数据结构<br>
**并查集(union-find)**，用于在不相交集合数据结构上的算法<br>
find: 判断子集中是否存在某个元素;或判断两个元素是否同属一个子集<br>
union: 将两个不相交的子集合并为一个子集<br>
时间复杂度为O(N)，N为元素个数．<br>
思路：根据条件判断两个元素是否同属一个子集(find步骤)，是则跳过，否则合并为新子集(union步骤)<br>
应用到无向图G=(V,E)环路检测中时，时间复杂度为O(E\*V)<br>
示例：G={(0,1),(1,2),(2,1)}<br>
1. 默认顶点V={0,1,2}各自从属独立子集,即0属于子集0,1属于子集1,2属于子集2
2. find E(0,1),发现V=0,1不属同一子集，然后就union成一个子集；否则排除该边

**find-union改进**<br>
启发式策略：<br>
路径压缩(Path Compression)，将深度为N的树压缩为2，即将所有子孙节点的父节点均设置为根节点．<br>
按秩合并(Union by Rank)，大吃小原则，就是集合规模大的根节点作为集合规模小的根节点的父节点．<br>


待学习：<br>
1. 线段数
2. 树状数组
3. Trie树（字典树）
4. 二叉搜索树
5. 红黑树

## c08 第八章 更多精彩算法
### 无向图最小生成树(Undirected Graph Minimum Spanning Tree)
**生成树(Spanning Tree)**，在加权连通图G=(V,E)中搜索无回路子集T,T为E的子集且T连接所有V.一个加权连通图可以包含多个生成树<br>
**最小生成树(Minimum Spanning Tree)**，在加权连通图G=(V,E)中搜索无回路子集T,T为E的子集且T连接所有V,并且其边权重之和最小<br>
`s01_kruskal`, Kruskal算法，生成无向图最小生成树．时间复杂度O(ElogV)<br>
思路：将边按权重从小到大排序，最多执行E轮操作，每轮操作均将权重最小且不构成环路的边加入到子集T中．当子集T的边数量达到V-1时，已经成功构成生成树，退出运算．
